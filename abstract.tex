This report explores the current state of verified programs research through
several lenses. We begin with a historical background of formal methods before
switching to formal verification in modern programming environments. In
particular, we examine verified user-programs and compilers. Next we categorize
verified programming tools along three (3) axes:
\begin{inlist}
\item interactivity,
\item proof logic, and
\item programming language.
\end{inlist}
Following that, we compare two extended examples of verified programs in
different systems. We also discuss a number of modern research projects and the
impacts they have had on formal verification, especially at scale and in
security-related settings. Lastly, we summarize the challenges of formal
verification in today's settings: notably, these include scaling proofs,
automation and proof management, symbolic explosion, and cross-language
verification. We conclude with a reminder that formal verification is another
tool in the programmer's toolbox and that the programmer must exercise
appropriate judgement in deciding which tool will solve a given problem.
